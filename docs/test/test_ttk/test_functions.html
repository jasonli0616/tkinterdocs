<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>tkinter.test.test_ttk.test_functions API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>tkinter.test.test_ttk.test_functions</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python"># -*- encoding: utf-8 -*-
import unittest
from tkinter import ttk

class MockTkApp:

    def splitlist(self, arg):
        if isinstance(arg, tuple):
            return arg
        return arg.split(&#39;:&#39;)

    def wantobjects(self):
        return True


class MockTclObj(object):
    typename = &#39;test&#39;

    def __init__(self, val):
        self.val = val

    def __str__(self):
        return str(self.val)


class MockStateSpec(object):
    typename = &#39;StateSpec&#39;

    def __init__(self, *args):
        self.val = args

    def __str__(self):
        return &#39; &#39;.join(self.val)


class InternalFunctionsTest(unittest.TestCase):

    def test_format_optdict(self):
        def check_against(fmt_opts, result):
            for i in range(0, len(fmt_opts), 2):
                self.assertEqual(result.pop(fmt_opts[i]), fmt_opts[i + 1])
            if result:
                self.fail(&#34;result still got elements: %s&#34; % result)

        # passing an empty dict should return an empty object (tuple here)
        self.assertFalse(ttk._format_optdict({}))

        # check list formatting
        check_against(
            ttk._format_optdict({&#39;fg&#39;: &#39;blue&#39;, &#39;padding&#39;: [1, 2, 3, 4]}),
            {&#39;-fg&#39;: &#39;blue&#39;, &#39;-padding&#39;: &#39;1 2 3 4&#39;})

        # check tuple formatting (same as list)
        check_against(
            ttk._format_optdict({&#39;test&#39;: (1, 2, &#39;&#39;, 0)}),
            {&#39;-test&#39;: &#39;1 2 {} 0&#39;})

        # check untouched values
        check_against(
            ttk._format_optdict({&#39;test&#39;: {&#39;left&#39;: &#39;as is&#39;}}),
            {&#39;-test&#39;: {&#39;left&#39;: &#39;as is&#39;}})

        # check script formatting
        check_against(
            ttk._format_optdict(
                {&#39;test&#39;: [1, -1, &#39;&#39;, &#39;2m&#39;, 0], &#39;test2&#39;: 3,
                 &#39;test3&#39;: &#39;&#39;, &#39;test4&#39;: &#39;abc def&#39;,
                 &#39;test5&#39;: &#39;&#34;abc&#34;&#39;, &#39;test6&#39;: &#39;{}&#39;,
                 &#39;test7&#39;: &#39;} -spam {&#39;}, script=True),
            {&#39;-test&#39;: &#39;{1 -1 {} 2m 0}&#39;, &#39;-test2&#39;: &#39;3&#39;,
             &#39;-test3&#39;: &#39;{}&#39;, &#39;-test4&#39;: &#39;{abc def}&#39;,
             &#39;-test5&#39;: &#39;{&#34;abc&#34;}&#39;, &#39;-test6&#39;: r&#39;\{\}&#39;,
             &#39;-test7&#39;: r&#39;\}\ -spam\ \{&#39;})

        opts = {&#39;αβγ&#39;: True, &#39;á&#39;: False}
        orig_opts = opts.copy()
        # check if giving unicode keys is fine
        check_against(ttk._format_optdict(opts), {&#39;-αβγ&#39;: True, &#39;-á&#39;: False})
        # opts should remain unchanged
        self.assertEqual(opts, orig_opts)

        # passing values with spaces inside a tuple/list
        check_against(
            ttk._format_optdict(
                {&#39;option&#39;: (&#39;one two&#39;, &#39;three&#39;)}),
            {&#39;-option&#39;: &#39;{one two} three&#39;})
        check_against(
            ttk._format_optdict(
                {&#39;option&#39;: (&#39;one\ttwo&#39;, &#39;three&#39;)}),
            {&#39;-option&#39;: &#39;{one\ttwo} three&#39;})

        # passing empty strings inside a tuple/list
        check_against(
            ttk._format_optdict(
                {&#39;option&#39;: (&#39;&#39;, &#39;one&#39;)}),
            {&#39;-option&#39;: &#39;{} one&#39;})

        # passing values with braces inside a tuple/list
        check_against(
            ttk._format_optdict(
                {&#39;option&#39;: (&#39;one} {two&#39;, &#39;three&#39;)}),
            {&#39;-option&#39;: r&#39;one\}\ \{two three&#39;})

        # passing quoted strings inside a tuple/list
        check_against(
            ttk._format_optdict(
                {&#39;option&#39;: (&#39;&#34;one&#34;&#39;, &#39;two&#39;)}),
            {&#39;-option&#39;: &#39;{&#34;one&#34;} two&#39;})
        check_against(
            ttk._format_optdict(
                {&#39;option&#39;: (&#39;{one}&#39;, &#39;two&#39;)}),
            {&#39;-option&#39;: r&#39;\{one\} two&#39;})

        # ignore an option
        amount_opts = len(ttk._format_optdict(opts, ignore=(&#39;á&#39;))) / 2
        self.assertEqual(amount_opts, len(opts) - 1)

        # ignore non-existing options
        amount_opts = len(ttk._format_optdict(opts, ignore=(&#39;á&#39;, &#39;b&#39;))) / 2
        self.assertEqual(amount_opts, len(opts) - 1)

        # ignore every option
        self.assertFalse(ttk._format_optdict(opts, ignore=list(opts.keys())))


    def test_format_mapdict(self):
        opts = {&#39;a&#39;: [(&#39;b&#39;, &#39;c&#39;, &#39;val&#39;), (&#39;d&#39;, &#39;otherval&#39;), (&#39;&#39;, &#39;single&#39;)]}
        result = ttk._format_mapdict(opts)
        self.assertEqual(len(result), len(list(opts.keys())) * 2)
        self.assertEqual(result, (&#39;-a&#39;, &#39;{b c} val d otherval {} single&#39;))
        self.assertEqual(ttk._format_mapdict(opts, script=True),
            (&#39;-a&#39;, &#39;{{b c} val d otherval {} single}&#39;))

        self.assertEqual(ttk._format_mapdict({2: []}), (&#39;-2&#39;, &#39;&#39;))

        opts = {&#39;üñíćódè&#39;: [(&#39;á&#39;, &#39;vãl&#39;)]}
        result = ttk._format_mapdict(opts)
        self.assertEqual(result, (&#39;-üñíćódè&#39;, &#39;á vãl&#39;))

        self.assertEqual(ttk._format_mapdict({&#39;opt&#39;: [(&#39;value&#39;,)]}),
                         (&#39;-opt&#39;, &#39;{} value&#39;))

        # empty states
        valid = {&#39;opt&#39;: [(&#39;&#39;, &#39;&#39;, &#39;hi&#39;)]}
        self.assertEqual(ttk._format_mapdict(valid), (&#39;-opt&#39;, &#39;{ } hi&#39;))

        # when passing multiple states, they all must be strings
        invalid = {&#39;opt&#39;: [(1, 2, &#39;valid val&#39;)]}
        self.assertRaises(TypeError, ttk._format_mapdict, invalid)
        invalid = {&#39;opt&#39;: [([1], &#39;2&#39;, &#39;valid val&#39;)]}
        self.assertRaises(TypeError, ttk._format_mapdict, invalid)
        # but when passing a single state, it can be anything
        valid = {&#39;opt&#39;: [[1, &#39;value&#39;]]}
        self.assertEqual(ttk._format_mapdict(valid), (&#39;-opt&#39;, &#39;1 value&#39;))
        # special attention to single states which evaluate to False
        for stateval in (None, 0, False, &#39;&#39;, set()): # just some samples
            valid = {&#39;opt&#39;: [(stateval, &#39;value&#39;)]}
            self.assertEqual(ttk._format_mapdict(valid),
                (&#39;-opt&#39;, &#39;{} value&#39;))

        # values must be iterable
        opts = {&#39;a&#39;: None}
        self.assertRaises(TypeError, ttk._format_mapdict, opts)


    def test_format_elemcreate(self):
        self.assertTrue(ttk._format_elemcreate(None), (None, ()))

        ## Testing type = image
        # image type expects at least an image name, so this should raise
        # IndexError since it tries to access the index 0 of an empty tuple
        self.assertRaises(IndexError, ttk._format_elemcreate, &#39;image&#39;)

        # don&#39;t format returned values as a tcl script
        # minimum acceptable for image type
        self.assertEqual(ttk._format_elemcreate(&#39;image&#39;, False, &#39;test&#39;),
            (&#34;test &#34;, ()))
        # specifying a state spec
        self.assertEqual(ttk._format_elemcreate(&#39;image&#39;, False, &#39;test&#39;,
            (&#39;&#39;, &#39;a&#39;)), (&#34;test {} a&#34;, ()))
        # state spec with multiple states
        self.assertEqual(ttk._format_elemcreate(&#39;image&#39;, False, &#39;test&#39;,
            (&#39;a&#39;, &#39;b&#39;, &#39;c&#39;)), (&#34;test {a b} c&#34;, ()))
        # state spec and options
        self.assertEqual(ttk._format_elemcreate(&#39;image&#39;, False, &#39;test&#39;,
            (&#39;a&#39;, &#39;b&#39;), a=&#39;x&#39;), (&#34;test a b&#34;, (&#34;-a&#34;, &#34;x&#34;)))
        # format returned values as a tcl script
        # state spec with multiple states and an option with a multivalue
        self.assertEqual(ttk._format_elemcreate(&#39;image&#39;, True, &#39;test&#39;,
            (&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;), x=[2, 3]), (&#34;{test {a b c} d}&#34;, &#34;-x {2 3}&#34;))

        ## Testing type = vsapi
        # vsapi type expects at least a class name and a part_id, so this
        # should raise a ValueError since it tries to get two elements from
        # an empty tuple
        self.assertRaises(ValueError, ttk._format_elemcreate, &#39;vsapi&#39;)

        # don&#39;t format returned values as a tcl script
        # minimum acceptable for vsapi
        self.assertEqual(ttk._format_elemcreate(&#39;vsapi&#39;, False, &#39;a&#39;, &#39;b&#39;),
            (&#34;a b &#34;, ()))
        # now with a state spec with multiple states
        self.assertEqual(ttk._format_elemcreate(&#39;vsapi&#39;, False, &#39;a&#39;, &#39;b&#39;,
            (&#39;a&#39;, &#39;b&#39;, &#39;c&#39;)), (&#34;a b {a b} c&#34;, ()))
        # state spec and option
        self.assertEqual(ttk._format_elemcreate(&#39;vsapi&#39;, False, &#39;a&#39;, &#39;b&#39;,
            (&#39;a&#39;, &#39;b&#39;), opt=&#39;x&#39;), (&#34;a b a b&#34;, (&#34;-opt&#34;, &#34;x&#34;)))
        # format returned values as a tcl script
        # state spec with a multivalue and an option
        self.assertEqual(ttk._format_elemcreate(&#39;vsapi&#39;, True, &#39;a&#39;, &#39;b&#39;,
            (&#39;a&#39;, &#39;b&#39;, [1, 2]), opt=&#39;x&#39;), (&#34;{a b {a b} {1 2}}&#34;, &#34;-opt x&#34;))

        # Testing type = from
        # from type expects at least a type name
        self.assertRaises(IndexError, ttk._format_elemcreate, &#39;from&#39;)

        self.assertEqual(ttk._format_elemcreate(&#39;from&#39;, False, &#39;a&#39;),
            (&#39;a&#39;, ()))
        self.assertEqual(ttk._format_elemcreate(&#39;from&#39;, False, &#39;a&#39;, &#39;b&#39;),
            (&#39;a&#39;, (&#39;b&#39;, )))
        self.assertEqual(ttk._format_elemcreate(&#39;from&#39;, True, &#39;a&#39;, &#39;b&#39;),
            (&#39;{a}&#39;, &#39;b&#39;))


    def test_format_layoutlist(self):
        def sample(indent=0, indent_size=2):
            return ttk._format_layoutlist(
            [(&#39;a&#39;, {&#39;other&#39;: [1, 2, 3], &#39;children&#39;:
                [(&#39;b&#39;, {&#39;children&#39;:
                    [(&#39;c&#39;, {&#39;children&#39;:
                        [(&#39;d&#39;, {&#39;nice&#39;: &#39;opt&#39;})], &#39;something&#39;: (1, 2)
                    })]
                })]
            })], indent=indent, indent_size=indent_size)[0]

        def sample_expected(indent=0, indent_size=2):
            spaces = lambda amount=0: &#39; &#39; * (amount + indent)
            return (
                &#34;%sa -other {1 2 3} -children {\n&#34;
                &#34;%sb -children {\n&#34;
                &#34;%sc -something {1 2} -children {\n&#34;
                &#34;%sd -nice opt\n&#34;
                &#34;%s}\n&#34;
                &#34;%s}\n&#34;
                &#34;%s}&#34; % (spaces(), spaces(indent_size),
                    spaces(2 * indent_size), spaces(3 * indent_size),
                    spaces(2 * indent_size), spaces(indent_size), spaces()))

        # empty layout
        self.assertEqual(ttk._format_layoutlist([])[0], &#39;&#39;)

        # _format_layoutlist always expects the second item (in every item)
        # to act like a dict (except when the value evaluates to False).
        self.assertRaises(AttributeError,
            ttk._format_layoutlist, [(&#39;a&#39;, &#39;b&#39;)])

        smallest = ttk._format_layoutlist([(&#39;a&#39;, None)], indent=0)
        self.assertEqual(smallest,
            ttk._format_layoutlist([(&#39;a&#39;, &#39;&#39;)], indent=0))
        self.assertEqual(smallest[0], &#39;a&#39;)

        # testing indentation levels
        self.assertEqual(sample(), sample_expected())
        for i in range(4):
            self.assertEqual(sample(i), sample_expected(i))
            self.assertEqual(sample(i, i), sample_expected(i, i))

        # invalid layout format, different kind of exceptions will be
        # raised by internal functions

        # plain wrong format
        self.assertRaises(ValueError, ttk._format_layoutlist,
            [&#39;bad&#39;, &#39;format&#39;])
        # will try to use iteritems in the &#39;bad&#39; string
        self.assertRaises(AttributeError, ttk._format_layoutlist,
           [(&#39;name&#39;, &#39;bad&#39;)])
        # bad children formatting
        self.assertRaises(ValueError, ttk._format_layoutlist,
            [(&#39;name&#39;, {&#39;children&#39;: {&#39;a&#39;: None}})])


    def test_script_from_settings(self):
        # empty options
        self.assertFalse(ttk._script_from_settings({&#39;name&#39;:
            {&#39;configure&#39;: None, &#39;map&#39;: None, &#39;element create&#39;: None}}))

        # empty layout
        self.assertEqual(
            ttk._script_from_settings({&#39;name&#39;: {&#39;layout&#39;: None}}),
            &#34;ttk::style layout name {\nnull\n}&#34;)

        configdict = {&#39;αβγ&#39;: True, &#39;á&#39;: False}
        self.assertTrue(
            ttk._script_from_settings({&#39;name&#39;: {&#39;configure&#39;: configdict}}))

        mapdict = {&#39;üñíćódè&#39;: [(&#39;á&#39;, &#39;vãl&#39;)]}
        self.assertTrue(
            ttk._script_from_settings({&#39;name&#39;: {&#39;map&#39;: mapdict}}))

        # invalid image element
        self.assertRaises(IndexError,
            ttk._script_from_settings, {&#39;name&#39;: {&#39;element create&#39;: [&#39;image&#39;]}})

        # minimal valid image
        self.assertTrue(ttk._script_from_settings({&#39;name&#39;:
            {&#39;element create&#39;: [&#39;image&#39;, &#39;name&#39;]}}))

        image = {&#39;thing&#39;: {&#39;element create&#39;:
            [&#39;image&#39;, &#39;name&#39;, (&#39;state1&#39;, &#39;state2&#39;, &#39;val&#39;)]}}
        self.assertEqual(ttk._script_from_settings(image),
            &#34;ttk::style element create thing image {name {state1 state2} val} &#34;)

        image[&#39;thing&#39;][&#39;element create&#39;].append({&#39;opt&#39;: 30})
        self.assertEqual(ttk._script_from_settings(image),
            &#34;ttk::style element create thing image {name {state1 state2} val} &#34;
            &#34;-opt 30&#34;)

        image[&#39;thing&#39;][&#39;element create&#39;][-1][&#39;opt&#39;] = [MockTclObj(3),
            MockTclObj(&#39;2m&#39;)]
        self.assertEqual(ttk._script_from_settings(image),
            &#34;ttk::style element create thing image {name {state1 state2} val} &#34;
            &#34;-opt {3 2m}&#34;)


    def test_tclobj_to_py(self):
        self.assertEqual(
            ttk._tclobj_to_py((MockStateSpec(&#39;a&#39;, &#39;b&#39;), &#39;val&#39;)),
            [(&#39;a&#39;, &#39;b&#39;, &#39;val&#39;)])
        self.assertEqual(
            ttk._tclobj_to_py([MockTclObj(&#39;1&#39;), 2, MockTclObj(&#39;3m&#39;)]),
            [1, 2, &#39;3m&#39;])


    def test_list_from_statespec(self):
        def test_it(sspec, value, res_value, states):
            self.assertEqual(ttk._list_from_statespec(
                (sspec, value)), [states + (res_value, )])

        states_even = tuple(&#39;state%d&#39; % i for i in range(6))
        statespec = MockStateSpec(*states_even)
        test_it(statespec, &#39;val&#39;, &#39;val&#39;, states_even)
        test_it(statespec, MockTclObj(&#39;val&#39;), &#39;val&#39;, states_even)

        states_odd = tuple(&#39;state%d&#39; % i for i in range(5))
        statespec = MockStateSpec(*states_odd)
        test_it(statespec, &#39;val&#39;, &#39;val&#39;, states_odd)

        test_it((&#39;a&#39;, &#39;b&#39;, &#39;c&#39;), MockTclObj(&#39;val&#39;), &#39;val&#39;, (&#39;a&#39;, &#39;b&#39;, &#39;c&#39;))


    def test_list_from_layouttuple(self):
        tk = MockTkApp()

        # empty layout tuple
        self.assertFalse(ttk._list_from_layouttuple(tk, ()))

        # shortest layout tuple
        self.assertEqual(ttk._list_from_layouttuple(tk, (&#39;name&#39;, )),
            [(&#39;name&#39;, {})])

        # not so interesting ltuple
        sample_ltuple = (&#39;name&#39;, &#39;-option&#39;, &#39;value&#39;)
        self.assertEqual(ttk._list_from_layouttuple(tk, sample_ltuple),
            [(&#39;name&#39;, {&#39;option&#39;: &#39;value&#39;})])

        # empty children
        self.assertEqual(ttk._list_from_layouttuple(tk,
            (&#39;something&#39;, &#39;-children&#39;, ())),
            [(&#39;something&#39;, {&#39;children&#39;: []})]
        )

        # more interesting ltuple
        ltuple = (
            &#39;name&#39;, &#39;-option&#39;, &#39;niceone&#39;, &#39;-children&#39;, (
                (&#39;otherone&#39;, &#39;-children&#39;, (
                    (&#39;child&#39;, )), &#39;-otheropt&#39;, &#39;othervalue&#39;
                )
            )
        )
        self.assertEqual(ttk._list_from_layouttuple(tk, ltuple),
            [(&#39;name&#39;, {&#39;option&#39;: &#39;niceone&#39;, &#39;children&#39;:
                [(&#39;otherone&#39;, {&#39;otheropt&#39;: &#39;othervalue&#39;, &#39;children&#39;:
                    [(&#39;child&#39;, {})]
                })]
            })]
        )

        # bad tuples
        self.assertRaises(ValueError, ttk._list_from_layouttuple, tk,
            (&#39;name&#39;, &#39;no_minus&#39;))
        self.assertRaises(ValueError, ttk._list_from_layouttuple, tk,
            (&#39;name&#39;, &#39;no_minus&#39;, &#39;value&#39;))
        self.assertRaises(ValueError, ttk._list_from_layouttuple, tk,
            (&#39;something&#39;, &#39;-children&#39;)) # no children


    def test_val_or_dict(self):
        def func(res, opt=None, val=None):
            if opt is None:
                return res
            if val is None:
                return &#34;test val&#34;
            return (opt, val)

        tk = MockTkApp()
        tk.call = func

        self.assertEqual(ttk._val_or_dict(tk, {}, &#39;-test:3&#39;),
                         {&#39;test&#39;: &#39;3&#39;})
        self.assertEqual(ttk._val_or_dict(tk, {}, (&#39;-test&#39;, 3)),
                         {&#39;test&#39;: 3})

        self.assertEqual(ttk._val_or_dict(tk, {&#39;test&#39;: None}, &#39;x:y&#39;),
                         &#39;test val&#39;)

        self.assertEqual(ttk._val_or_dict(tk, {&#39;test&#39;: 3}, &#39;x:y&#39;),
                         {&#39;test&#39;: 3})


    def test_convert_stringval(self):
        tests = (
            (0, 0), (&#39;09&#39;, 9), (&#39;a&#39;, &#39;a&#39;), (&#39;áÚ&#39;, &#39;áÚ&#39;), ([], &#39;[]&#39;),
            (None, &#39;None&#39;)
        )
        for orig, expected in tests:
            self.assertEqual(ttk._convert_stringval(orig), expected)


class TclObjsToPyTest(unittest.TestCase):

    def test_unicode(self):
        adict = {&#39;opt&#39;: &#39;välúè&#39;}
        self.assertEqual(ttk.tclobjs_to_py(adict), {&#39;opt&#39;: &#39;välúè&#39;})

        adict[&#39;opt&#39;] = MockTclObj(adict[&#39;opt&#39;])
        self.assertEqual(ttk.tclobjs_to_py(adict), {&#39;opt&#39;: &#39;välúè&#39;})

    def test_multivalues(self):
        adict = {&#39;opt&#39;: [1, 2, 3, 4]}
        self.assertEqual(ttk.tclobjs_to_py(adict), {&#39;opt&#39;: [1, 2, 3, 4]})

        adict[&#39;opt&#39;] = [1, &#39;xm&#39;, 3]
        self.assertEqual(ttk.tclobjs_to_py(adict), {&#39;opt&#39;: [1, &#39;xm&#39;, 3]})

        adict[&#39;opt&#39;] = (MockStateSpec(&#39;a&#39;, &#39;b&#39;), &#39;válũè&#39;)
        self.assertEqual(ttk.tclobjs_to_py(adict),
            {&#39;opt&#39;: [(&#39;a&#39;, &#39;b&#39;, &#39;válũè&#39;)]})

        self.assertEqual(ttk.tclobjs_to_py({&#39;x&#39;: [&#39;y z&#39;]}),
            {&#39;x&#39;: [&#39;y z&#39;]})

    def test_nosplit(self):
        self.assertEqual(ttk.tclobjs_to_py({&#39;text&#39;: &#39;some text&#39;}),
            {&#39;text&#39;: &#39;some text&#39;})

tests_nogui = (InternalFunctionsTest, TclObjsToPyTest)

if __name__ == &#34;__main__&#34;:
    from test.support import run_unittest
    run_unittest(*tests_nogui)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="tkinter.test.test_ttk.test_functions.InternalFunctionsTest"><code class="flex name class">
<span>class <span class="ident">InternalFunctionsTest</span></span>
<span>(</span><span>methodName='runTest')</span>
</code></dt>
<dd>
<div class="desc"><p>A class whose instances are single test cases.</p>
<p>By default, the test code itself should be placed in a method named
'runTest'.</p>
<p>If the fixture may be used for many test cases, create as
many test methods as are needed. When instantiating such a TestCase
subclass, specify in the constructor arguments the name of the test method
that the instance is to execute.</p>
<p>Test authors should subclass TestCase for their own tests. Construction
and deconstruction of the test's environment ('fixture') can be
implemented by overriding the 'setUp' and 'tearDown' methods respectively.</p>
<p>If it is necessary to override the <strong>init</strong> method, the base class
<strong>init</strong> method must always be called. It is important that subclasses
should not change the signature of their <strong>init</strong> method, since instances
of the classes are instantiated automatically by parts of the framework
in order to be run.</p>
<p>When subclassing TestCase, you can set these attributes:
* failureException: determines which exception will be raised when
the instance's assertion methods fail; test methods raising this
exception will be deemed to have 'failed' rather than 'errored'.
* longMessage: determines whether long messages (including repr of
objects used in assert methods) will be printed on failure in <em>addition</em>
to any explicit message passed.
* maxDiff: sets the maximum length of a diff in failure messages
by assert methods using difflib. It is looked up as an instance
attribute so can be configured by individual tests if required.</p>
<p>Create an instance of the class that will use the named test
method when executed. Raises a ValueError if the instance does
not have a method with the specified name.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class InternalFunctionsTest(unittest.TestCase):

    def test_format_optdict(self):
        def check_against(fmt_opts, result):
            for i in range(0, len(fmt_opts), 2):
                self.assertEqual(result.pop(fmt_opts[i]), fmt_opts[i + 1])
            if result:
                self.fail(&#34;result still got elements: %s&#34; % result)

        # passing an empty dict should return an empty object (tuple here)
        self.assertFalse(ttk._format_optdict({}))

        # check list formatting
        check_against(
            ttk._format_optdict({&#39;fg&#39;: &#39;blue&#39;, &#39;padding&#39;: [1, 2, 3, 4]}),
            {&#39;-fg&#39;: &#39;blue&#39;, &#39;-padding&#39;: &#39;1 2 3 4&#39;})

        # check tuple formatting (same as list)
        check_against(
            ttk._format_optdict({&#39;test&#39;: (1, 2, &#39;&#39;, 0)}),
            {&#39;-test&#39;: &#39;1 2 {} 0&#39;})

        # check untouched values
        check_against(
            ttk._format_optdict({&#39;test&#39;: {&#39;left&#39;: &#39;as is&#39;}}),
            {&#39;-test&#39;: {&#39;left&#39;: &#39;as is&#39;}})

        # check script formatting
        check_against(
            ttk._format_optdict(
                {&#39;test&#39;: [1, -1, &#39;&#39;, &#39;2m&#39;, 0], &#39;test2&#39;: 3,
                 &#39;test3&#39;: &#39;&#39;, &#39;test4&#39;: &#39;abc def&#39;,
                 &#39;test5&#39;: &#39;&#34;abc&#34;&#39;, &#39;test6&#39;: &#39;{}&#39;,
                 &#39;test7&#39;: &#39;} -spam {&#39;}, script=True),
            {&#39;-test&#39;: &#39;{1 -1 {} 2m 0}&#39;, &#39;-test2&#39;: &#39;3&#39;,
             &#39;-test3&#39;: &#39;{}&#39;, &#39;-test4&#39;: &#39;{abc def}&#39;,
             &#39;-test5&#39;: &#39;{&#34;abc&#34;}&#39;, &#39;-test6&#39;: r&#39;\{\}&#39;,
             &#39;-test7&#39;: r&#39;\}\ -spam\ \{&#39;})

        opts = {&#39;αβγ&#39;: True, &#39;á&#39;: False}
        orig_opts = opts.copy()
        # check if giving unicode keys is fine
        check_against(ttk._format_optdict(opts), {&#39;-αβγ&#39;: True, &#39;-á&#39;: False})
        # opts should remain unchanged
        self.assertEqual(opts, orig_opts)

        # passing values with spaces inside a tuple/list
        check_against(
            ttk._format_optdict(
                {&#39;option&#39;: (&#39;one two&#39;, &#39;three&#39;)}),
            {&#39;-option&#39;: &#39;{one two} three&#39;})
        check_against(
            ttk._format_optdict(
                {&#39;option&#39;: (&#39;one\ttwo&#39;, &#39;three&#39;)}),
            {&#39;-option&#39;: &#39;{one\ttwo} three&#39;})

        # passing empty strings inside a tuple/list
        check_against(
            ttk._format_optdict(
                {&#39;option&#39;: (&#39;&#39;, &#39;one&#39;)}),
            {&#39;-option&#39;: &#39;{} one&#39;})

        # passing values with braces inside a tuple/list
        check_against(
            ttk._format_optdict(
                {&#39;option&#39;: (&#39;one} {two&#39;, &#39;three&#39;)}),
            {&#39;-option&#39;: r&#39;one\}\ \{two three&#39;})

        # passing quoted strings inside a tuple/list
        check_against(
            ttk._format_optdict(
                {&#39;option&#39;: (&#39;&#34;one&#34;&#39;, &#39;two&#39;)}),
            {&#39;-option&#39;: &#39;{&#34;one&#34;} two&#39;})
        check_against(
            ttk._format_optdict(
                {&#39;option&#39;: (&#39;{one}&#39;, &#39;two&#39;)}),
            {&#39;-option&#39;: r&#39;\{one\} two&#39;})

        # ignore an option
        amount_opts = len(ttk._format_optdict(opts, ignore=(&#39;á&#39;))) / 2
        self.assertEqual(amount_opts, len(opts) - 1)

        # ignore non-existing options
        amount_opts = len(ttk._format_optdict(opts, ignore=(&#39;á&#39;, &#39;b&#39;))) / 2
        self.assertEqual(amount_opts, len(opts) - 1)

        # ignore every option
        self.assertFalse(ttk._format_optdict(opts, ignore=list(opts.keys())))


    def test_format_mapdict(self):
        opts = {&#39;a&#39;: [(&#39;b&#39;, &#39;c&#39;, &#39;val&#39;), (&#39;d&#39;, &#39;otherval&#39;), (&#39;&#39;, &#39;single&#39;)]}
        result = ttk._format_mapdict(opts)
        self.assertEqual(len(result), len(list(opts.keys())) * 2)
        self.assertEqual(result, (&#39;-a&#39;, &#39;{b c} val d otherval {} single&#39;))
        self.assertEqual(ttk._format_mapdict(opts, script=True),
            (&#39;-a&#39;, &#39;{{b c} val d otherval {} single}&#39;))

        self.assertEqual(ttk._format_mapdict({2: []}), (&#39;-2&#39;, &#39;&#39;))

        opts = {&#39;üñíćódè&#39;: [(&#39;á&#39;, &#39;vãl&#39;)]}
        result = ttk._format_mapdict(opts)
        self.assertEqual(result, (&#39;-üñíćódè&#39;, &#39;á vãl&#39;))

        self.assertEqual(ttk._format_mapdict({&#39;opt&#39;: [(&#39;value&#39;,)]}),
                         (&#39;-opt&#39;, &#39;{} value&#39;))

        # empty states
        valid = {&#39;opt&#39;: [(&#39;&#39;, &#39;&#39;, &#39;hi&#39;)]}
        self.assertEqual(ttk._format_mapdict(valid), (&#39;-opt&#39;, &#39;{ } hi&#39;))

        # when passing multiple states, they all must be strings
        invalid = {&#39;opt&#39;: [(1, 2, &#39;valid val&#39;)]}
        self.assertRaises(TypeError, ttk._format_mapdict, invalid)
        invalid = {&#39;opt&#39;: [([1], &#39;2&#39;, &#39;valid val&#39;)]}
        self.assertRaises(TypeError, ttk._format_mapdict, invalid)
        # but when passing a single state, it can be anything
        valid = {&#39;opt&#39;: [[1, &#39;value&#39;]]}
        self.assertEqual(ttk._format_mapdict(valid), (&#39;-opt&#39;, &#39;1 value&#39;))
        # special attention to single states which evaluate to False
        for stateval in (None, 0, False, &#39;&#39;, set()): # just some samples
            valid = {&#39;opt&#39;: [(stateval, &#39;value&#39;)]}
            self.assertEqual(ttk._format_mapdict(valid),
                (&#39;-opt&#39;, &#39;{} value&#39;))

        # values must be iterable
        opts = {&#39;a&#39;: None}
        self.assertRaises(TypeError, ttk._format_mapdict, opts)


    def test_format_elemcreate(self):
        self.assertTrue(ttk._format_elemcreate(None), (None, ()))

        ## Testing type = image
        # image type expects at least an image name, so this should raise
        # IndexError since it tries to access the index 0 of an empty tuple
        self.assertRaises(IndexError, ttk._format_elemcreate, &#39;image&#39;)

        # don&#39;t format returned values as a tcl script
        # minimum acceptable for image type
        self.assertEqual(ttk._format_elemcreate(&#39;image&#39;, False, &#39;test&#39;),
            (&#34;test &#34;, ()))
        # specifying a state spec
        self.assertEqual(ttk._format_elemcreate(&#39;image&#39;, False, &#39;test&#39;,
            (&#39;&#39;, &#39;a&#39;)), (&#34;test {} a&#34;, ()))
        # state spec with multiple states
        self.assertEqual(ttk._format_elemcreate(&#39;image&#39;, False, &#39;test&#39;,
            (&#39;a&#39;, &#39;b&#39;, &#39;c&#39;)), (&#34;test {a b} c&#34;, ()))
        # state spec and options
        self.assertEqual(ttk._format_elemcreate(&#39;image&#39;, False, &#39;test&#39;,
            (&#39;a&#39;, &#39;b&#39;), a=&#39;x&#39;), (&#34;test a b&#34;, (&#34;-a&#34;, &#34;x&#34;)))
        # format returned values as a tcl script
        # state spec with multiple states and an option with a multivalue
        self.assertEqual(ttk._format_elemcreate(&#39;image&#39;, True, &#39;test&#39;,
            (&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;), x=[2, 3]), (&#34;{test {a b c} d}&#34;, &#34;-x {2 3}&#34;))

        ## Testing type = vsapi
        # vsapi type expects at least a class name and a part_id, so this
        # should raise a ValueError since it tries to get two elements from
        # an empty tuple
        self.assertRaises(ValueError, ttk._format_elemcreate, &#39;vsapi&#39;)

        # don&#39;t format returned values as a tcl script
        # minimum acceptable for vsapi
        self.assertEqual(ttk._format_elemcreate(&#39;vsapi&#39;, False, &#39;a&#39;, &#39;b&#39;),
            (&#34;a b &#34;, ()))
        # now with a state spec with multiple states
        self.assertEqual(ttk._format_elemcreate(&#39;vsapi&#39;, False, &#39;a&#39;, &#39;b&#39;,
            (&#39;a&#39;, &#39;b&#39;, &#39;c&#39;)), (&#34;a b {a b} c&#34;, ()))
        # state spec and option
        self.assertEqual(ttk._format_elemcreate(&#39;vsapi&#39;, False, &#39;a&#39;, &#39;b&#39;,
            (&#39;a&#39;, &#39;b&#39;), opt=&#39;x&#39;), (&#34;a b a b&#34;, (&#34;-opt&#34;, &#34;x&#34;)))
        # format returned values as a tcl script
        # state spec with a multivalue and an option
        self.assertEqual(ttk._format_elemcreate(&#39;vsapi&#39;, True, &#39;a&#39;, &#39;b&#39;,
            (&#39;a&#39;, &#39;b&#39;, [1, 2]), opt=&#39;x&#39;), (&#34;{a b {a b} {1 2}}&#34;, &#34;-opt x&#34;))

        # Testing type = from
        # from type expects at least a type name
        self.assertRaises(IndexError, ttk._format_elemcreate, &#39;from&#39;)

        self.assertEqual(ttk._format_elemcreate(&#39;from&#39;, False, &#39;a&#39;),
            (&#39;a&#39;, ()))
        self.assertEqual(ttk._format_elemcreate(&#39;from&#39;, False, &#39;a&#39;, &#39;b&#39;),
            (&#39;a&#39;, (&#39;b&#39;, )))
        self.assertEqual(ttk._format_elemcreate(&#39;from&#39;, True, &#39;a&#39;, &#39;b&#39;),
            (&#39;{a}&#39;, &#39;b&#39;))


    def test_format_layoutlist(self):
        def sample(indent=0, indent_size=2):
            return ttk._format_layoutlist(
            [(&#39;a&#39;, {&#39;other&#39;: [1, 2, 3], &#39;children&#39;:
                [(&#39;b&#39;, {&#39;children&#39;:
                    [(&#39;c&#39;, {&#39;children&#39;:
                        [(&#39;d&#39;, {&#39;nice&#39;: &#39;opt&#39;})], &#39;something&#39;: (1, 2)
                    })]
                })]
            })], indent=indent, indent_size=indent_size)[0]

        def sample_expected(indent=0, indent_size=2):
            spaces = lambda amount=0: &#39; &#39; * (amount + indent)
            return (
                &#34;%sa -other {1 2 3} -children {\n&#34;
                &#34;%sb -children {\n&#34;
                &#34;%sc -something {1 2} -children {\n&#34;
                &#34;%sd -nice opt\n&#34;
                &#34;%s}\n&#34;
                &#34;%s}\n&#34;
                &#34;%s}&#34; % (spaces(), spaces(indent_size),
                    spaces(2 * indent_size), spaces(3 * indent_size),
                    spaces(2 * indent_size), spaces(indent_size), spaces()))

        # empty layout
        self.assertEqual(ttk._format_layoutlist([])[0], &#39;&#39;)

        # _format_layoutlist always expects the second item (in every item)
        # to act like a dict (except when the value evaluates to False).
        self.assertRaises(AttributeError,
            ttk._format_layoutlist, [(&#39;a&#39;, &#39;b&#39;)])

        smallest = ttk._format_layoutlist([(&#39;a&#39;, None)], indent=0)
        self.assertEqual(smallest,
            ttk._format_layoutlist([(&#39;a&#39;, &#39;&#39;)], indent=0))
        self.assertEqual(smallest[0], &#39;a&#39;)

        # testing indentation levels
        self.assertEqual(sample(), sample_expected())
        for i in range(4):
            self.assertEqual(sample(i), sample_expected(i))
            self.assertEqual(sample(i, i), sample_expected(i, i))

        # invalid layout format, different kind of exceptions will be
        # raised by internal functions

        # plain wrong format
        self.assertRaises(ValueError, ttk._format_layoutlist,
            [&#39;bad&#39;, &#39;format&#39;])
        # will try to use iteritems in the &#39;bad&#39; string
        self.assertRaises(AttributeError, ttk._format_layoutlist,
           [(&#39;name&#39;, &#39;bad&#39;)])
        # bad children formatting
        self.assertRaises(ValueError, ttk._format_layoutlist,
            [(&#39;name&#39;, {&#39;children&#39;: {&#39;a&#39;: None}})])


    def test_script_from_settings(self):
        # empty options
        self.assertFalse(ttk._script_from_settings({&#39;name&#39;:
            {&#39;configure&#39;: None, &#39;map&#39;: None, &#39;element create&#39;: None}}))

        # empty layout
        self.assertEqual(
            ttk._script_from_settings({&#39;name&#39;: {&#39;layout&#39;: None}}),
            &#34;ttk::style layout name {\nnull\n}&#34;)

        configdict = {&#39;αβγ&#39;: True, &#39;á&#39;: False}
        self.assertTrue(
            ttk._script_from_settings({&#39;name&#39;: {&#39;configure&#39;: configdict}}))

        mapdict = {&#39;üñíćódè&#39;: [(&#39;á&#39;, &#39;vãl&#39;)]}
        self.assertTrue(
            ttk._script_from_settings({&#39;name&#39;: {&#39;map&#39;: mapdict}}))

        # invalid image element
        self.assertRaises(IndexError,
            ttk._script_from_settings, {&#39;name&#39;: {&#39;element create&#39;: [&#39;image&#39;]}})

        # minimal valid image
        self.assertTrue(ttk._script_from_settings({&#39;name&#39;:
            {&#39;element create&#39;: [&#39;image&#39;, &#39;name&#39;]}}))

        image = {&#39;thing&#39;: {&#39;element create&#39;:
            [&#39;image&#39;, &#39;name&#39;, (&#39;state1&#39;, &#39;state2&#39;, &#39;val&#39;)]}}
        self.assertEqual(ttk._script_from_settings(image),
            &#34;ttk::style element create thing image {name {state1 state2} val} &#34;)

        image[&#39;thing&#39;][&#39;element create&#39;].append({&#39;opt&#39;: 30})
        self.assertEqual(ttk._script_from_settings(image),
            &#34;ttk::style element create thing image {name {state1 state2} val} &#34;
            &#34;-opt 30&#34;)

        image[&#39;thing&#39;][&#39;element create&#39;][-1][&#39;opt&#39;] = [MockTclObj(3),
            MockTclObj(&#39;2m&#39;)]
        self.assertEqual(ttk._script_from_settings(image),
            &#34;ttk::style element create thing image {name {state1 state2} val} &#34;
            &#34;-opt {3 2m}&#34;)


    def test_tclobj_to_py(self):
        self.assertEqual(
            ttk._tclobj_to_py((MockStateSpec(&#39;a&#39;, &#39;b&#39;), &#39;val&#39;)),
            [(&#39;a&#39;, &#39;b&#39;, &#39;val&#39;)])
        self.assertEqual(
            ttk._tclobj_to_py([MockTclObj(&#39;1&#39;), 2, MockTclObj(&#39;3m&#39;)]),
            [1, 2, &#39;3m&#39;])


    def test_list_from_statespec(self):
        def test_it(sspec, value, res_value, states):
            self.assertEqual(ttk._list_from_statespec(
                (sspec, value)), [states + (res_value, )])

        states_even = tuple(&#39;state%d&#39; % i for i in range(6))
        statespec = MockStateSpec(*states_even)
        test_it(statespec, &#39;val&#39;, &#39;val&#39;, states_even)
        test_it(statespec, MockTclObj(&#39;val&#39;), &#39;val&#39;, states_even)

        states_odd = tuple(&#39;state%d&#39; % i for i in range(5))
        statespec = MockStateSpec(*states_odd)
        test_it(statespec, &#39;val&#39;, &#39;val&#39;, states_odd)

        test_it((&#39;a&#39;, &#39;b&#39;, &#39;c&#39;), MockTclObj(&#39;val&#39;), &#39;val&#39;, (&#39;a&#39;, &#39;b&#39;, &#39;c&#39;))


    def test_list_from_layouttuple(self):
        tk = MockTkApp()

        # empty layout tuple
        self.assertFalse(ttk._list_from_layouttuple(tk, ()))

        # shortest layout tuple
        self.assertEqual(ttk._list_from_layouttuple(tk, (&#39;name&#39;, )),
            [(&#39;name&#39;, {})])

        # not so interesting ltuple
        sample_ltuple = (&#39;name&#39;, &#39;-option&#39;, &#39;value&#39;)
        self.assertEqual(ttk._list_from_layouttuple(tk, sample_ltuple),
            [(&#39;name&#39;, {&#39;option&#39;: &#39;value&#39;})])

        # empty children
        self.assertEqual(ttk._list_from_layouttuple(tk,
            (&#39;something&#39;, &#39;-children&#39;, ())),
            [(&#39;something&#39;, {&#39;children&#39;: []})]
        )

        # more interesting ltuple
        ltuple = (
            &#39;name&#39;, &#39;-option&#39;, &#39;niceone&#39;, &#39;-children&#39;, (
                (&#39;otherone&#39;, &#39;-children&#39;, (
                    (&#39;child&#39;, )), &#39;-otheropt&#39;, &#39;othervalue&#39;
                )
            )
        )
        self.assertEqual(ttk._list_from_layouttuple(tk, ltuple),
            [(&#39;name&#39;, {&#39;option&#39;: &#39;niceone&#39;, &#39;children&#39;:
                [(&#39;otherone&#39;, {&#39;otheropt&#39;: &#39;othervalue&#39;, &#39;children&#39;:
                    [(&#39;child&#39;, {})]
                })]
            })]
        )

        # bad tuples
        self.assertRaises(ValueError, ttk._list_from_layouttuple, tk,
            (&#39;name&#39;, &#39;no_minus&#39;))
        self.assertRaises(ValueError, ttk._list_from_layouttuple, tk,
            (&#39;name&#39;, &#39;no_minus&#39;, &#39;value&#39;))
        self.assertRaises(ValueError, ttk._list_from_layouttuple, tk,
            (&#39;something&#39;, &#39;-children&#39;)) # no children


    def test_val_or_dict(self):
        def func(res, opt=None, val=None):
            if opt is None:
                return res
            if val is None:
                return &#34;test val&#34;
            return (opt, val)

        tk = MockTkApp()
        tk.call = func

        self.assertEqual(ttk._val_or_dict(tk, {}, &#39;-test:3&#39;),
                         {&#39;test&#39;: &#39;3&#39;})
        self.assertEqual(ttk._val_or_dict(tk, {}, (&#39;-test&#39;, 3)),
                         {&#39;test&#39;: 3})

        self.assertEqual(ttk._val_or_dict(tk, {&#39;test&#39;: None}, &#39;x:y&#39;),
                         &#39;test val&#39;)

        self.assertEqual(ttk._val_or_dict(tk, {&#39;test&#39;: 3}, &#39;x:y&#39;),
                         {&#39;test&#39;: 3})


    def test_convert_stringval(self):
        tests = (
            (0, 0), (&#39;09&#39;, 9), (&#39;a&#39;, &#39;a&#39;), (&#39;áÚ&#39;, &#39;áÚ&#39;), ([], &#39;[]&#39;),
            (None, &#39;None&#39;)
        )
        for orig, expected in tests:
            self.assertEqual(ttk._convert_stringval(orig), expected)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>unittest.case.TestCase</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="tkinter.test.test_ttk.test_functions.InternalFunctionsTest.test_convert_stringval"><code class="name flex">
<span>def <span class="ident">test_convert_stringval</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def test_convert_stringval(self):
    tests = (
        (0, 0), (&#39;09&#39;, 9), (&#39;a&#39;, &#39;a&#39;), (&#39;áÚ&#39;, &#39;áÚ&#39;), ([], &#39;[]&#39;),
        (None, &#39;None&#39;)
    )
    for orig, expected in tests:
        self.assertEqual(ttk._convert_stringval(orig), expected)</code></pre>
</details>
</dd>
<dt id="tkinter.test.test_ttk.test_functions.InternalFunctionsTest.test_format_elemcreate"><code class="name flex">
<span>def <span class="ident">test_format_elemcreate</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def test_format_elemcreate(self):
    self.assertTrue(ttk._format_elemcreate(None), (None, ()))

    ## Testing type = image
    # image type expects at least an image name, so this should raise
    # IndexError since it tries to access the index 0 of an empty tuple
    self.assertRaises(IndexError, ttk._format_elemcreate, &#39;image&#39;)

    # don&#39;t format returned values as a tcl script
    # minimum acceptable for image type
    self.assertEqual(ttk._format_elemcreate(&#39;image&#39;, False, &#39;test&#39;),
        (&#34;test &#34;, ()))
    # specifying a state spec
    self.assertEqual(ttk._format_elemcreate(&#39;image&#39;, False, &#39;test&#39;,
        (&#39;&#39;, &#39;a&#39;)), (&#34;test {} a&#34;, ()))
    # state spec with multiple states
    self.assertEqual(ttk._format_elemcreate(&#39;image&#39;, False, &#39;test&#39;,
        (&#39;a&#39;, &#39;b&#39;, &#39;c&#39;)), (&#34;test {a b} c&#34;, ()))
    # state spec and options
    self.assertEqual(ttk._format_elemcreate(&#39;image&#39;, False, &#39;test&#39;,
        (&#39;a&#39;, &#39;b&#39;), a=&#39;x&#39;), (&#34;test a b&#34;, (&#34;-a&#34;, &#34;x&#34;)))
    # format returned values as a tcl script
    # state spec with multiple states and an option with a multivalue
    self.assertEqual(ttk._format_elemcreate(&#39;image&#39;, True, &#39;test&#39;,
        (&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;), x=[2, 3]), (&#34;{test {a b c} d}&#34;, &#34;-x {2 3}&#34;))

    ## Testing type = vsapi
    # vsapi type expects at least a class name and a part_id, so this
    # should raise a ValueError since it tries to get two elements from
    # an empty tuple
    self.assertRaises(ValueError, ttk._format_elemcreate, &#39;vsapi&#39;)

    # don&#39;t format returned values as a tcl script
    # minimum acceptable for vsapi
    self.assertEqual(ttk._format_elemcreate(&#39;vsapi&#39;, False, &#39;a&#39;, &#39;b&#39;),
        (&#34;a b &#34;, ()))
    # now with a state spec with multiple states
    self.assertEqual(ttk._format_elemcreate(&#39;vsapi&#39;, False, &#39;a&#39;, &#39;b&#39;,
        (&#39;a&#39;, &#39;b&#39;, &#39;c&#39;)), (&#34;a b {a b} c&#34;, ()))
    # state spec and option
    self.assertEqual(ttk._format_elemcreate(&#39;vsapi&#39;, False, &#39;a&#39;, &#39;b&#39;,
        (&#39;a&#39;, &#39;b&#39;), opt=&#39;x&#39;), (&#34;a b a b&#34;, (&#34;-opt&#34;, &#34;x&#34;)))
    # format returned values as a tcl script
    # state spec with a multivalue and an option
    self.assertEqual(ttk._format_elemcreate(&#39;vsapi&#39;, True, &#39;a&#39;, &#39;b&#39;,
        (&#39;a&#39;, &#39;b&#39;, [1, 2]), opt=&#39;x&#39;), (&#34;{a b {a b} {1 2}}&#34;, &#34;-opt x&#34;))

    # Testing type = from
    # from type expects at least a type name
    self.assertRaises(IndexError, ttk._format_elemcreate, &#39;from&#39;)

    self.assertEqual(ttk._format_elemcreate(&#39;from&#39;, False, &#39;a&#39;),
        (&#39;a&#39;, ()))
    self.assertEqual(ttk._format_elemcreate(&#39;from&#39;, False, &#39;a&#39;, &#39;b&#39;),
        (&#39;a&#39;, (&#39;b&#39;, )))
    self.assertEqual(ttk._format_elemcreate(&#39;from&#39;, True, &#39;a&#39;, &#39;b&#39;),
        (&#39;{a}&#39;, &#39;b&#39;))</code></pre>
</details>
</dd>
<dt id="tkinter.test.test_ttk.test_functions.InternalFunctionsTest.test_format_layoutlist"><code class="name flex">
<span>def <span class="ident">test_format_layoutlist</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def test_format_layoutlist(self):
    def sample(indent=0, indent_size=2):
        return ttk._format_layoutlist(
        [(&#39;a&#39;, {&#39;other&#39;: [1, 2, 3], &#39;children&#39;:
            [(&#39;b&#39;, {&#39;children&#39;:
                [(&#39;c&#39;, {&#39;children&#39;:
                    [(&#39;d&#39;, {&#39;nice&#39;: &#39;opt&#39;})], &#39;something&#39;: (1, 2)
                })]
            })]
        })], indent=indent, indent_size=indent_size)[0]

    def sample_expected(indent=0, indent_size=2):
        spaces = lambda amount=0: &#39; &#39; * (amount + indent)
        return (
            &#34;%sa -other {1 2 3} -children {\n&#34;
            &#34;%sb -children {\n&#34;
            &#34;%sc -something {1 2} -children {\n&#34;
            &#34;%sd -nice opt\n&#34;
            &#34;%s}\n&#34;
            &#34;%s}\n&#34;
            &#34;%s}&#34; % (spaces(), spaces(indent_size),
                spaces(2 * indent_size), spaces(3 * indent_size),
                spaces(2 * indent_size), spaces(indent_size), spaces()))

    # empty layout
    self.assertEqual(ttk._format_layoutlist([])[0], &#39;&#39;)

    # _format_layoutlist always expects the second item (in every item)
    # to act like a dict (except when the value evaluates to False).
    self.assertRaises(AttributeError,
        ttk._format_layoutlist, [(&#39;a&#39;, &#39;b&#39;)])

    smallest = ttk._format_layoutlist([(&#39;a&#39;, None)], indent=0)
    self.assertEqual(smallest,
        ttk._format_layoutlist([(&#39;a&#39;, &#39;&#39;)], indent=0))
    self.assertEqual(smallest[0], &#39;a&#39;)

    # testing indentation levels
    self.assertEqual(sample(), sample_expected())
    for i in range(4):
        self.assertEqual(sample(i), sample_expected(i))
        self.assertEqual(sample(i, i), sample_expected(i, i))

    # invalid layout format, different kind of exceptions will be
    # raised by internal functions

    # plain wrong format
    self.assertRaises(ValueError, ttk._format_layoutlist,
        [&#39;bad&#39;, &#39;format&#39;])
    # will try to use iteritems in the &#39;bad&#39; string
    self.assertRaises(AttributeError, ttk._format_layoutlist,
       [(&#39;name&#39;, &#39;bad&#39;)])
    # bad children formatting
    self.assertRaises(ValueError, ttk._format_layoutlist,
        [(&#39;name&#39;, {&#39;children&#39;: {&#39;a&#39;: None}})])</code></pre>
</details>
</dd>
<dt id="tkinter.test.test_ttk.test_functions.InternalFunctionsTest.test_format_mapdict"><code class="name flex">
<span>def <span class="ident">test_format_mapdict</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def test_format_mapdict(self):
    opts = {&#39;a&#39;: [(&#39;b&#39;, &#39;c&#39;, &#39;val&#39;), (&#39;d&#39;, &#39;otherval&#39;), (&#39;&#39;, &#39;single&#39;)]}
    result = ttk._format_mapdict(opts)
    self.assertEqual(len(result), len(list(opts.keys())) * 2)
    self.assertEqual(result, (&#39;-a&#39;, &#39;{b c} val d otherval {} single&#39;))
    self.assertEqual(ttk._format_mapdict(opts, script=True),
        (&#39;-a&#39;, &#39;{{b c} val d otherval {} single}&#39;))

    self.assertEqual(ttk._format_mapdict({2: []}), (&#39;-2&#39;, &#39;&#39;))

    opts = {&#39;üñíćódè&#39;: [(&#39;á&#39;, &#39;vãl&#39;)]}
    result = ttk._format_mapdict(opts)
    self.assertEqual(result, (&#39;-üñíćódè&#39;, &#39;á vãl&#39;))

    self.assertEqual(ttk._format_mapdict({&#39;opt&#39;: [(&#39;value&#39;,)]}),
                     (&#39;-opt&#39;, &#39;{} value&#39;))

    # empty states
    valid = {&#39;opt&#39;: [(&#39;&#39;, &#39;&#39;, &#39;hi&#39;)]}
    self.assertEqual(ttk._format_mapdict(valid), (&#39;-opt&#39;, &#39;{ } hi&#39;))

    # when passing multiple states, they all must be strings
    invalid = {&#39;opt&#39;: [(1, 2, &#39;valid val&#39;)]}
    self.assertRaises(TypeError, ttk._format_mapdict, invalid)
    invalid = {&#39;opt&#39;: [([1], &#39;2&#39;, &#39;valid val&#39;)]}
    self.assertRaises(TypeError, ttk._format_mapdict, invalid)
    # but when passing a single state, it can be anything
    valid = {&#39;opt&#39;: [[1, &#39;value&#39;]]}
    self.assertEqual(ttk._format_mapdict(valid), (&#39;-opt&#39;, &#39;1 value&#39;))
    # special attention to single states which evaluate to False
    for stateval in (None, 0, False, &#39;&#39;, set()): # just some samples
        valid = {&#39;opt&#39;: [(stateval, &#39;value&#39;)]}
        self.assertEqual(ttk._format_mapdict(valid),
            (&#39;-opt&#39;, &#39;{} value&#39;))

    # values must be iterable
    opts = {&#39;a&#39;: None}
    self.assertRaises(TypeError, ttk._format_mapdict, opts)</code></pre>
</details>
</dd>
<dt id="tkinter.test.test_ttk.test_functions.InternalFunctionsTest.test_format_optdict"><code class="name flex">
<span>def <span class="ident">test_format_optdict</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def test_format_optdict(self):
    def check_against(fmt_opts, result):
        for i in range(0, len(fmt_opts), 2):
            self.assertEqual(result.pop(fmt_opts[i]), fmt_opts[i + 1])
        if result:
            self.fail(&#34;result still got elements: %s&#34; % result)

    # passing an empty dict should return an empty object (tuple here)
    self.assertFalse(ttk._format_optdict({}))

    # check list formatting
    check_against(
        ttk._format_optdict({&#39;fg&#39;: &#39;blue&#39;, &#39;padding&#39;: [1, 2, 3, 4]}),
        {&#39;-fg&#39;: &#39;blue&#39;, &#39;-padding&#39;: &#39;1 2 3 4&#39;})

    # check tuple formatting (same as list)
    check_against(
        ttk._format_optdict({&#39;test&#39;: (1, 2, &#39;&#39;, 0)}),
        {&#39;-test&#39;: &#39;1 2 {} 0&#39;})

    # check untouched values
    check_against(
        ttk._format_optdict({&#39;test&#39;: {&#39;left&#39;: &#39;as is&#39;}}),
        {&#39;-test&#39;: {&#39;left&#39;: &#39;as is&#39;}})

    # check script formatting
    check_against(
        ttk._format_optdict(
            {&#39;test&#39;: [1, -1, &#39;&#39;, &#39;2m&#39;, 0], &#39;test2&#39;: 3,
             &#39;test3&#39;: &#39;&#39;, &#39;test4&#39;: &#39;abc def&#39;,
             &#39;test5&#39;: &#39;&#34;abc&#34;&#39;, &#39;test6&#39;: &#39;{}&#39;,
             &#39;test7&#39;: &#39;} -spam {&#39;}, script=True),
        {&#39;-test&#39;: &#39;{1 -1 {} 2m 0}&#39;, &#39;-test2&#39;: &#39;3&#39;,
         &#39;-test3&#39;: &#39;{}&#39;, &#39;-test4&#39;: &#39;{abc def}&#39;,
         &#39;-test5&#39;: &#39;{&#34;abc&#34;}&#39;, &#39;-test6&#39;: r&#39;\{\}&#39;,
         &#39;-test7&#39;: r&#39;\}\ -spam\ \{&#39;})

    opts = {&#39;αβγ&#39;: True, &#39;á&#39;: False}
    orig_opts = opts.copy()
    # check if giving unicode keys is fine
    check_against(ttk._format_optdict(opts), {&#39;-αβγ&#39;: True, &#39;-á&#39;: False})
    # opts should remain unchanged
    self.assertEqual(opts, orig_opts)

    # passing values with spaces inside a tuple/list
    check_against(
        ttk._format_optdict(
            {&#39;option&#39;: (&#39;one two&#39;, &#39;three&#39;)}),
        {&#39;-option&#39;: &#39;{one two} three&#39;})
    check_against(
        ttk._format_optdict(
            {&#39;option&#39;: (&#39;one\ttwo&#39;, &#39;three&#39;)}),
        {&#39;-option&#39;: &#39;{one\ttwo} three&#39;})

    # passing empty strings inside a tuple/list
    check_against(
        ttk._format_optdict(
            {&#39;option&#39;: (&#39;&#39;, &#39;one&#39;)}),
        {&#39;-option&#39;: &#39;{} one&#39;})

    # passing values with braces inside a tuple/list
    check_against(
        ttk._format_optdict(
            {&#39;option&#39;: (&#39;one} {two&#39;, &#39;three&#39;)}),
        {&#39;-option&#39;: r&#39;one\}\ \{two three&#39;})

    # passing quoted strings inside a tuple/list
    check_against(
        ttk._format_optdict(
            {&#39;option&#39;: (&#39;&#34;one&#34;&#39;, &#39;two&#39;)}),
        {&#39;-option&#39;: &#39;{&#34;one&#34;} two&#39;})
    check_against(
        ttk._format_optdict(
            {&#39;option&#39;: (&#39;{one}&#39;, &#39;two&#39;)}),
        {&#39;-option&#39;: r&#39;\{one\} two&#39;})

    # ignore an option
    amount_opts = len(ttk._format_optdict(opts, ignore=(&#39;á&#39;))) / 2
    self.assertEqual(amount_opts, len(opts) - 1)

    # ignore non-existing options
    amount_opts = len(ttk._format_optdict(opts, ignore=(&#39;á&#39;, &#39;b&#39;))) / 2
    self.assertEqual(amount_opts, len(opts) - 1)

    # ignore every option
    self.assertFalse(ttk._format_optdict(opts, ignore=list(opts.keys())))</code></pre>
</details>
</dd>
<dt id="tkinter.test.test_ttk.test_functions.InternalFunctionsTest.test_list_from_layouttuple"><code class="name flex">
<span>def <span class="ident">test_list_from_layouttuple</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def test_list_from_layouttuple(self):
    tk = MockTkApp()

    # empty layout tuple
    self.assertFalse(ttk._list_from_layouttuple(tk, ()))

    # shortest layout tuple
    self.assertEqual(ttk._list_from_layouttuple(tk, (&#39;name&#39;, )),
        [(&#39;name&#39;, {})])

    # not so interesting ltuple
    sample_ltuple = (&#39;name&#39;, &#39;-option&#39;, &#39;value&#39;)
    self.assertEqual(ttk._list_from_layouttuple(tk, sample_ltuple),
        [(&#39;name&#39;, {&#39;option&#39;: &#39;value&#39;})])

    # empty children
    self.assertEqual(ttk._list_from_layouttuple(tk,
        (&#39;something&#39;, &#39;-children&#39;, ())),
        [(&#39;something&#39;, {&#39;children&#39;: []})]
    )

    # more interesting ltuple
    ltuple = (
        &#39;name&#39;, &#39;-option&#39;, &#39;niceone&#39;, &#39;-children&#39;, (
            (&#39;otherone&#39;, &#39;-children&#39;, (
                (&#39;child&#39;, )), &#39;-otheropt&#39;, &#39;othervalue&#39;
            )
        )
    )
    self.assertEqual(ttk._list_from_layouttuple(tk, ltuple),
        [(&#39;name&#39;, {&#39;option&#39;: &#39;niceone&#39;, &#39;children&#39;:
            [(&#39;otherone&#39;, {&#39;otheropt&#39;: &#39;othervalue&#39;, &#39;children&#39;:
                [(&#39;child&#39;, {})]
            })]
        })]
    )

    # bad tuples
    self.assertRaises(ValueError, ttk._list_from_layouttuple, tk,
        (&#39;name&#39;, &#39;no_minus&#39;))
    self.assertRaises(ValueError, ttk._list_from_layouttuple, tk,
        (&#39;name&#39;, &#39;no_minus&#39;, &#39;value&#39;))
    self.assertRaises(ValueError, ttk._list_from_layouttuple, tk,
        (&#39;something&#39;, &#39;-children&#39;)) # no children</code></pre>
</details>
</dd>
<dt id="tkinter.test.test_ttk.test_functions.InternalFunctionsTest.test_list_from_statespec"><code class="name flex">
<span>def <span class="ident">test_list_from_statespec</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def test_list_from_statespec(self):
    def test_it(sspec, value, res_value, states):
        self.assertEqual(ttk._list_from_statespec(
            (sspec, value)), [states + (res_value, )])

    states_even = tuple(&#39;state%d&#39; % i for i in range(6))
    statespec = MockStateSpec(*states_even)
    test_it(statespec, &#39;val&#39;, &#39;val&#39;, states_even)
    test_it(statespec, MockTclObj(&#39;val&#39;), &#39;val&#39;, states_even)

    states_odd = tuple(&#39;state%d&#39; % i for i in range(5))
    statespec = MockStateSpec(*states_odd)
    test_it(statespec, &#39;val&#39;, &#39;val&#39;, states_odd)

    test_it((&#39;a&#39;, &#39;b&#39;, &#39;c&#39;), MockTclObj(&#39;val&#39;), &#39;val&#39;, (&#39;a&#39;, &#39;b&#39;, &#39;c&#39;))</code></pre>
</details>
</dd>
<dt id="tkinter.test.test_ttk.test_functions.InternalFunctionsTest.test_script_from_settings"><code class="name flex">
<span>def <span class="ident">test_script_from_settings</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def test_script_from_settings(self):
    # empty options
    self.assertFalse(ttk._script_from_settings({&#39;name&#39;:
        {&#39;configure&#39;: None, &#39;map&#39;: None, &#39;element create&#39;: None}}))

    # empty layout
    self.assertEqual(
        ttk._script_from_settings({&#39;name&#39;: {&#39;layout&#39;: None}}),
        &#34;ttk::style layout name {\nnull\n}&#34;)

    configdict = {&#39;αβγ&#39;: True, &#39;á&#39;: False}
    self.assertTrue(
        ttk._script_from_settings({&#39;name&#39;: {&#39;configure&#39;: configdict}}))

    mapdict = {&#39;üñíćódè&#39;: [(&#39;á&#39;, &#39;vãl&#39;)]}
    self.assertTrue(
        ttk._script_from_settings({&#39;name&#39;: {&#39;map&#39;: mapdict}}))

    # invalid image element
    self.assertRaises(IndexError,
        ttk._script_from_settings, {&#39;name&#39;: {&#39;element create&#39;: [&#39;image&#39;]}})

    # minimal valid image
    self.assertTrue(ttk._script_from_settings({&#39;name&#39;:
        {&#39;element create&#39;: [&#39;image&#39;, &#39;name&#39;]}}))

    image = {&#39;thing&#39;: {&#39;element create&#39;:
        [&#39;image&#39;, &#39;name&#39;, (&#39;state1&#39;, &#39;state2&#39;, &#39;val&#39;)]}}
    self.assertEqual(ttk._script_from_settings(image),
        &#34;ttk::style element create thing image {name {state1 state2} val} &#34;)

    image[&#39;thing&#39;][&#39;element create&#39;].append({&#39;opt&#39;: 30})
    self.assertEqual(ttk._script_from_settings(image),
        &#34;ttk::style element create thing image {name {state1 state2} val} &#34;
        &#34;-opt 30&#34;)

    image[&#39;thing&#39;][&#39;element create&#39;][-1][&#39;opt&#39;] = [MockTclObj(3),
        MockTclObj(&#39;2m&#39;)]
    self.assertEqual(ttk._script_from_settings(image),
        &#34;ttk::style element create thing image {name {state1 state2} val} &#34;
        &#34;-opt {3 2m}&#34;)</code></pre>
</details>
</dd>
<dt id="tkinter.test.test_ttk.test_functions.InternalFunctionsTest.test_tclobj_to_py"><code class="name flex">
<span>def <span class="ident">test_tclobj_to_py</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def test_tclobj_to_py(self):
    self.assertEqual(
        ttk._tclobj_to_py((MockStateSpec(&#39;a&#39;, &#39;b&#39;), &#39;val&#39;)),
        [(&#39;a&#39;, &#39;b&#39;, &#39;val&#39;)])
    self.assertEqual(
        ttk._tclobj_to_py([MockTclObj(&#39;1&#39;), 2, MockTclObj(&#39;3m&#39;)]),
        [1, 2, &#39;3m&#39;])</code></pre>
</details>
</dd>
<dt id="tkinter.test.test_ttk.test_functions.InternalFunctionsTest.test_val_or_dict"><code class="name flex">
<span>def <span class="ident">test_val_or_dict</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def test_val_or_dict(self):
    def func(res, opt=None, val=None):
        if opt is None:
            return res
        if val is None:
            return &#34;test val&#34;
        return (opt, val)

    tk = MockTkApp()
    tk.call = func

    self.assertEqual(ttk._val_or_dict(tk, {}, &#39;-test:3&#39;),
                     {&#39;test&#39;: &#39;3&#39;})
    self.assertEqual(ttk._val_or_dict(tk, {}, (&#39;-test&#39;, 3)),
                     {&#39;test&#39;: 3})

    self.assertEqual(ttk._val_or_dict(tk, {&#39;test&#39;: None}, &#39;x:y&#39;),
                     &#39;test val&#39;)

    self.assertEqual(ttk._val_or_dict(tk, {&#39;test&#39;: 3}, &#39;x:y&#39;),
                     {&#39;test&#39;: 3})</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="tkinter.test.test_ttk.test_functions.MockStateSpec"><code class="flex name class">
<span>class <span class="ident">MockStateSpec</span></span>
<span>(</span><span>*args)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class MockStateSpec(object):
    typename = &#39;StateSpec&#39;

    def __init__(self, *args):
        self.val = args

    def __str__(self):
        return &#39; &#39;.join(self.val)</code></pre>
</details>
<h3>Class variables</h3>
<dl>
<dt id="tkinter.test.test_ttk.test_functions.MockStateSpec.typename"><code class="name">var <span class="ident">typename</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
</dd>
<dt id="tkinter.test.test_ttk.test_functions.MockTclObj"><code class="flex name class">
<span>class <span class="ident">MockTclObj</span></span>
<span>(</span><span>val)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class MockTclObj(object):
    typename = &#39;test&#39;

    def __init__(self, val):
        self.val = val

    def __str__(self):
        return str(self.val)</code></pre>
</details>
<h3>Class variables</h3>
<dl>
<dt id="tkinter.test.test_ttk.test_functions.MockTclObj.typename"><code class="name">var <span class="ident">typename</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
</dd>
<dt id="tkinter.test.test_ttk.test_functions.MockTkApp"><code class="flex name class">
<span>class <span class="ident">MockTkApp</span></span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class MockTkApp:

    def splitlist(self, arg):
        if isinstance(arg, tuple):
            return arg
        return arg.split(&#39;:&#39;)

    def wantobjects(self):
        return True</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="tkinter.test.test_ttk.test_functions.MockTkApp.splitlist"><code class="name flex">
<span>def <span class="ident">splitlist</span></span>(<span>self, arg)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def splitlist(self, arg):
    if isinstance(arg, tuple):
        return arg
    return arg.split(&#39;:&#39;)</code></pre>
</details>
</dd>
<dt id="tkinter.test.test_ttk.test_functions.MockTkApp.wantobjects"><code class="name flex">
<span>def <span class="ident">wantobjects</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def wantobjects(self):
    return True</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="tkinter.test.test_ttk.test_functions.TclObjsToPyTest"><code class="flex name class">
<span>class <span class="ident">TclObjsToPyTest</span></span>
<span>(</span><span>methodName='runTest')</span>
</code></dt>
<dd>
<div class="desc"><p>A class whose instances are single test cases.</p>
<p>By default, the test code itself should be placed in a method named
'runTest'.</p>
<p>If the fixture may be used for many test cases, create as
many test methods as are needed. When instantiating such a TestCase
subclass, specify in the constructor arguments the name of the test method
that the instance is to execute.</p>
<p>Test authors should subclass TestCase for their own tests. Construction
and deconstruction of the test's environment ('fixture') can be
implemented by overriding the 'setUp' and 'tearDown' methods respectively.</p>
<p>If it is necessary to override the <strong>init</strong> method, the base class
<strong>init</strong> method must always be called. It is important that subclasses
should not change the signature of their <strong>init</strong> method, since instances
of the classes are instantiated automatically by parts of the framework
in order to be run.</p>
<p>When subclassing TestCase, you can set these attributes:
* failureException: determines which exception will be raised when
the instance's assertion methods fail; test methods raising this
exception will be deemed to have 'failed' rather than 'errored'.
* longMessage: determines whether long messages (including repr of
objects used in assert methods) will be printed on failure in <em>addition</em>
to any explicit message passed.
* maxDiff: sets the maximum length of a diff in failure messages
by assert methods using difflib. It is looked up as an instance
attribute so can be configured by individual tests if required.</p>
<p>Create an instance of the class that will use the named test
method when executed. Raises a ValueError if the instance does
not have a method with the specified name.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class TclObjsToPyTest(unittest.TestCase):

    def test_unicode(self):
        adict = {&#39;opt&#39;: &#39;välúè&#39;}
        self.assertEqual(ttk.tclobjs_to_py(adict), {&#39;opt&#39;: &#39;välúè&#39;})

        adict[&#39;opt&#39;] = MockTclObj(adict[&#39;opt&#39;])
        self.assertEqual(ttk.tclobjs_to_py(adict), {&#39;opt&#39;: &#39;välúè&#39;})

    def test_multivalues(self):
        adict = {&#39;opt&#39;: [1, 2, 3, 4]}
        self.assertEqual(ttk.tclobjs_to_py(adict), {&#39;opt&#39;: [1, 2, 3, 4]})

        adict[&#39;opt&#39;] = [1, &#39;xm&#39;, 3]
        self.assertEqual(ttk.tclobjs_to_py(adict), {&#39;opt&#39;: [1, &#39;xm&#39;, 3]})

        adict[&#39;opt&#39;] = (MockStateSpec(&#39;a&#39;, &#39;b&#39;), &#39;válũè&#39;)
        self.assertEqual(ttk.tclobjs_to_py(adict),
            {&#39;opt&#39;: [(&#39;a&#39;, &#39;b&#39;, &#39;válũè&#39;)]})

        self.assertEqual(ttk.tclobjs_to_py({&#39;x&#39;: [&#39;y z&#39;]}),
            {&#39;x&#39;: [&#39;y z&#39;]})

    def test_nosplit(self):
        self.assertEqual(ttk.tclobjs_to_py({&#39;text&#39;: &#39;some text&#39;}),
            {&#39;text&#39;: &#39;some text&#39;})</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>unittest.case.TestCase</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="tkinter.test.test_ttk.test_functions.TclObjsToPyTest.test_multivalues"><code class="name flex">
<span>def <span class="ident">test_multivalues</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def test_multivalues(self):
    adict = {&#39;opt&#39;: [1, 2, 3, 4]}
    self.assertEqual(ttk.tclobjs_to_py(adict), {&#39;opt&#39;: [1, 2, 3, 4]})

    adict[&#39;opt&#39;] = [1, &#39;xm&#39;, 3]
    self.assertEqual(ttk.tclobjs_to_py(adict), {&#39;opt&#39;: [1, &#39;xm&#39;, 3]})

    adict[&#39;opt&#39;] = (MockStateSpec(&#39;a&#39;, &#39;b&#39;), &#39;válũè&#39;)
    self.assertEqual(ttk.tclobjs_to_py(adict),
        {&#39;opt&#39;: [(&#39;a&#39;, &#39;b&#39;, &#39;válũè&#39;)]})

    self.assertEqual(ttk.tclobjs_to_py({&#39;x&#39;: [&#39;y z&#39;]}),
        {&#39;x&#39;: [&#39;y z&#39;]})</code></pre>
</details>
</dd>
<dt id="tkinter.test.test_ttk.test_functions.TclObjsToPyTest.test_nosplit"><code class="name flex">
<span>def <span class="ident">test_nosplit</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def test_nosplit(self):
    self.assertEqual(ttk.tclobjs_to_py({&#39;text&#39;: &#39;some text&#39;}),
        {&#39;text&#39;: &#39;some text&#39;})</code></pre>
</details>
</dd>
<dt id="tkinter.test.test_ttk.test_functions.TclObjsToPyTest.test_unicode"><code class="name flex">
<span>def <span class="ident">test_unicode</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def test_unicode(self):
    adict = {&#39;opt&#39;: &#39;välúè&#39;}
    self.assertEqual(ttk.tclobjs_to_py(adict), {&#39;opt&#39;: &#39;välúè&#39;})

    adict[&#39;opt&#39;] = MockTclObj(adict[&#39;opt&#39;])
    self.assertEqual(ttk.tclobjs_to_py(adict), {&#39;opt&#39;: &#39;välúè&#39;})</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="tkinter.test.test_ttk" href="index.html">tkinter.test.test_ttk</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="tkinter.test.test_ttk.test_functions.InternalFunctionsTest" href="#tkinter.test.test_ttk.test_functions.InternalFunctionsTest">InternalFunctionsTest</a></code></h4>
<ul class="">
<li><code><a title="tkinter.test.test_ttk.test_functions.InternalFunctionsTest.test_convert_stringval" href="#tkinter.test.test_ttk.test_functions.InternalFunctionsTest.test_convert_stringval">test_convert_stringval</a></code></li>
<li><code><a title="tkinter.test.test_ttk.test_functions.InternalFunctionsTest.test_format_elemcreate" href="#tkinter.test.test_ttk.test_functions.InternalFunctionsTest.test_format_elemcreate">test_format_elemcreate</a></code></li>
<li><code><a title="tkinter.test.test_ttk.test_functions.InternalFunctionsTest.test_format_layoutlist" href="#tkinter.test.test_ttk.test_functions.InternalFunctionsTest.test_format_layoutlist">test_format_layoutlist</a></code></li>
<li><code><a title="tkinter.test.test_ttk.test_functions.InternalFunctionsTest.test_format_mapdict" href="#tkinter.test.test_ttk.test_functions.InternalFunctionsTest.test_format_mapdict">test_format_mapdict</a></code></li>
<li><code><a title="tkinter.test.test_ttk.test_functions.InternalFunctionsTest.test_format_optdict" href="#tkinter.test.test_ttk.test_functions.InternalFunctionsTest.test_format_optdict">test_format_optdict</a></code></li>
<li><code><a title="tkinter.test.test_ttk.test_functions.InternalFunctionsTest.test_list_from_layouttuple" href="#tkinter.test.test_ttk.test_functions.InternalFunctionsTest.test_list_from_layouttuple">test_list_from_layouttuple</a></code></li>
<li><code><a title="tkinter.test.test_ttk.test_functions.InternalFunctionsTest.test_list_from_statespec" href="#tkinter.test.test_ttk.test_functions.InternalFunctionsTest.test_list_from_statespec">test_list_from_statespec</a></code></li>
<li><code><a title="tkinter.test.test_ttk.test_functions.InternalFunctionsTest.test_script_from_settings" href="#tkinter.test.test_ttk.test_functions.InternalFunctionsTest.test_script_from_settings">test_script_from_settings</a></code></li>
<li><code><a title="tkinter.test.test_ttk.test_functions.InternalFunctionsTest.test_tclobj_to_py" href="#tkinter.test.test_ttk.test_functions.InternalFunctionsTest.test_tclobj_to_py">test_tclobj_to_py</a></code></li>
<li><code><a title="tkinter.test.test_ttk.test_functions.InternalFunctionsTest.test_val_or_dict" href="#tkinter.test.test_ttk.test_functions.InternalFunctionsTest.test_val_or_dict">test_val_or_dict</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="tkinter.test.test_ttk.test_functions.MockStateSpec" href="#tkinter.test.test_ttk.test_functions.MockStateSpec">MockStateSpec</a></code></h4>
<ul class="">
<li><code><a title="tkinter.test.test_ttk.test_functions.MockStateSpec.typename" href="#tkinter.test.test_ttk.test_functions.MockStateSpec.typename">typename</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="tkinter.test.test_ttk.test_functions.MockTclObj" href="#tkinter.test.test_ttk.test_functions.MockTclObj">MockTclObj</a></code></h4>
<ul class="">
<li><code><a title="tkinter.test.test_ttk.test_functions.MockTclObj.typename" href="#tkinter.test.test_ttk.test_functions.MockTclObj.typename">typename</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="tkinter.test.test_ttk.test_functions.MockTkApp" href="#tkinter.test.test_ttk.test_functions.MockTkApp">MockTkApp</a></code></h4>
<ul class="">
<li><code><a title="tkinter.test.test_ttk.test_functions.MockTkApp.splitlist" href="#tkinter.test.test_ttk.test_functions.MockTkApp.splitlist">splitlist</a></code></li>
<li><code><a title="tkinter.test.test_ttk.test_functions.MockTkApp.wantobjects" href="#tkinter.test.test_ttk.test_functions.MockTkApp.wantobjects">wantobjects</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="tkinter.test.test_ttk.test_functions.TclObjsToPyTest" href="#tkinter.test.test_ttk.test_functions.TclObjsToPyTest">TclObjsToPyTest</a></code></h4>
<ul class="">
<li><code><a title="tkinter.test.test_ttk.test_functions.TclObjsToPyTest.test_multivalues" href="#tkinter.test.test_ttk.test_functions.TclObjsToPyTest.test_multivalues">test_multivalues</a></code></li>
<li><code><a title="tkinter.test.test_ttk.test_functions.TclObjsToPyTest.test_nosplit" href="#tkinter.test.test_ttk.test_functions.TclObjsToPyTest.test_nosplit">test_nosplit</a></code></li>
<li><code><a title="tkinter.test.test_ttk.test_functions.TclObjsToPyTest.test_unicode" href="#tkinter.test.test_ttk.test_functions.TclObjsToPyTest.test_unicode">test_unicode</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>